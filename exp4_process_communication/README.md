# 实验四 linux 进程管理
## (1)实现一个模拟的 shell
编写三个不同的程序 cmd1.c，cmd2.c，cmd3.c，每个程序的功能自定，分别编译成可执 行文件 cmd1，cmd2，cmd3。然后再编写一个程序，模拟 shell 程序的功能，能根据用户输 入的字符串（表示相应的命令名），去为相应的命令创建子进程并让它去执行相应的程序，而父进程则等待子进程结束，然后再等待接收下一条命令。如果接收到的命令为 exit，则父 进程结束；如果接收到的命令是无效命令，则显示“Command not found”，继续等待。
## (2)实现一个管道通信程序
由父进程创建一个管道，然后再创建 3 个子进程，并由这三个子进程利用管道与父进程 之间进行通信：子进程发送信息，父进程等三个子进程全部发完消息后再接收信息。通信的 具体内容可根据自己的需要随意设计，要求能试验阻塞型读写过程中的各种情况，测试管道 的默认大小，并且要求利用 Posix 信号量机制实现进程间对管道的互斥访问。运行程序，观 察各种情况下，进程实际读写的字节数以及进程阻塞唤醒的情况。
## (3)利用 linux 的消息队列通信机制实现两个线程间的通信
编写程序创建两个线程：sender 线程和 re'eive 线程，其中 sender 线程运行函数 sender()， 它创建一个消息队列，然后，循环等待用户通过终端输入一串字符，将这串字符通过消息队 列发送给 receiver 线程，直到用户输入“exit”为止；最后，它向 receiver 线程发送消息“end”， 并且等待 receiver 的应答，等到应答消息后，将接收到的应答信息显示在终端屏幕上，删除 相关消息队列，结束程序的运行。Receiver 线程运行 receive()，它通过消息队列接收来自 sender 的消息，将消息显示在终端屏幕上，直至收到内容为“end”的消息为止，此时，它 向 sender 发送一个应答消息“over”，结束程序的运行。使用无名信号量实现两个线程之间 的同步与互斥。
## (4)利用 linux 的共享内存通信机制实现两个进程间的通信
编写程序 sender，它创建一个共享内存，然后等待用户通过终端输入一串字符，并将这 串字符通过共享内存发送给 receiver；最后，它等待 receiver 的应答，收到应答消息后，将 接收到的应答信息显示在终端屏幕上，删除共享内存，结束程序的运行。编写 receiver 程序， 它通过共享内存接收来自 sender 的消息，将消息显示在终端屏幕上，然后再通过该共享内 存向 sender 发送一个应答消息“over”，结束程序的运行。使用有名信号量或 System V 信号 量实现两个进程对共享内存的互斥及同步使用。
***
![](https://static.notion-static.com/31d52ca24f804679bc15c859573799e9/_2017-12-07_23-50-14.png)

## (1) shmid_ds

每个共享内存段在内核中维护着一个内部结构shmid_ds

    struct shmid_ds{
     struct ipc_perm shm_perm;/* 操作权限*/
     int shm_segsz; /*段的大小（以字节为单位）*/
     time_t shm_atime; /*最后一个进程附加到该段的时间*/
     time_t shm_dtime; /*最后一个进程离开该段的时间*/
     time_t shm_ctime; /*最后一个进程修改该段的时间*/
     unsigned short shm_cpid; /*创建该段进程的pid*/
     unsigned short shm_lpid; /*在该段上操作的最后1个进程的pid*/
     short shm_nattch; /*当前附加到该段的进程的个数*/
    /*下面是私有的*/
     unsigned short shm_npages; /*段的大小（以页为单位）*/
     unsigned long *shm_pages; /*指向frames->SHMMAX的指针数组*/
     struct vm_area_struct *attaches; /*对共享段的描述*/
    };

## (2) ftok()函数

 通过ftok得到系统建立IPC通讯 （消息队列、信号量和共享内存） 时必须指定一个ID值

key_t ftok( char * fname, int id )fname就时你指定的文件名(该文件必须是存在而且可以访问的)，id是子序号， **虽然为int，但是只有8个比特被使用(0-255)。** 

## (3) linux常用的IPC(进程间的通讯方式)

（1）无名管道(pipe)：管道可用于具有亲缘关系的进程间的通信，是一种半双工的方式，数据只能单向流动，允许一个进程和另一个与它有共同祖先的进程之间进行通信。

（2）有名管道(FIFO)：命名管道克服了管道没有名字的限制，同时除了具有管道的功能外（也是半双工），它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。

（3）信号（signal）：信号是比较复杂的通信方式，用于通知接收进程有某种事件发生了，除了进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。

（4）消息队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺

（5）共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

（6）内存映射：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。

（7）信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。

（8）套接字（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

## (4) 消息队列

1. 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
2. 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
3. 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

## (5) 共享内存

1. 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
2. 因为多个进程可以同时操作，所以需要进行同步。
3. 无名信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

## (6) 信号量

1. 信号量用于进程间同步，若要在进程间传递数据需要结合 _共享内存_ 。
2. 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。

## (7) POSIX信号量和System V信号量的区别

1. 前者兼容性强，后者来源于AT&T System V，是Unix操作系统众多版本中的一支
2. 前者使用头文件<semaphore>,后者使用头文件<sys/sem.h>
3. System V操作的PV操作不一定是-1或者+1 ，可以同时请求和释放多个资源

      sembuf结构体：
      struct sembuf {
       shortsem_num;
       shortsem_op;
       shortsem_flg;
      };
       [//sem_op是信号量一次PV操作时加减的数值](//sem_op是信号量一次PV操作时加减的数值) 

4. System V信号量支持信号量组 

int semget(key_t key, int num_sems, int sem_flags);

 `num_sems 表示初始化信号量的个数` 

 `AND信号量机制,联系哲学家进餐问题` 

## (8) 信号和信号量的区别

1. 前者是使用信号处理器来进行的，后者是使用P,V操作来实现的。
2. 使用信号要先知道有哪些信号，在Linux下有31个需要记住的通用信号
3. 在使用信号以前，首先要初始化信号集，只有在信号集里面的信号才会被考虑。
4. 信号是实现约定的固定的值，而信号量是一 **个** 变量记录着某些特定信息。
5. 信号通知进程发生了异步事件（内存越界,kill），信号量实现进程之间的同步和互斥
6. 信号类似于中断，什么时候产生信号，进程是不知道的。
