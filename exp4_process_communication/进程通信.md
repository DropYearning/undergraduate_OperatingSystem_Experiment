# 进程通信

![](https://static.notion-static.com/31d52ca24f804679bc15c859573799e9/_2017-12-07_23-50-14.png)

## (1) shmid_ds

每个共享内存段在内核中维护着一个内部结构shmid_ds

    struct shmid_ds{
     struct ipc_perm shm_perm;/* 操作权限*/
     int shm_segsz; /*段的大小（以字节为单位）*/
     time_t shm_atime; /*最后一个进程附加到该段的时间*/
     time_t shm_dtime; /*最后一个进程离开该段的时间*/
     time_t shm_ctime; /*最后一个进程修改该段的时间*/
     unsigned short shm_cpid; /*创建该段进程的pid*/
     unsigned short shm_lpid; /*在该段上操作的最后1个进程的pid*/
     short shm_nattch; /*当前附加到该段的进程的个数*/
    /*下面是私有的*/
     unsigned short shm_npages; /*段的大小（以页为单位）*/
     unsigned long *shm_pages; /*指向frames->SHMMAX的指针数组*/
     struct vm_area_struct *attaches; /*对共享段的描述*/
    };

## (2) ftok()函数

 通过ftok得到系统建立IPC通讯 （消息队列、信号量和共享内存） 时必须指定一个ID值

key_t ftok( char * fname, int id )fname就时你指定的文件名(该文件必须是存在而且可以访问的)，id是子序号， **虽然为int，但是只有8个比特被使用(0-255)。** 

## (3) linux常用的IPC(进程间的通讯方式)

（1）无名管道(pipe)：管道可用于具有亲缘关系的进程间的通信，是一种半双工的方式，数据只能单向流动，允许一个进程和另一个与它有共同祖先的进程之间进行通信。

（2）有名管道(FIFO)：命名管道克服了管道没有名字的限制，同时除了具有管道的功能外（也是半双工），它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。

（3）信号（signal）：信号是比较复杂的通信方式，用于通知接收进程有某种事件发生了，除了进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。

（4）消息队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺

（5）共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

（6）内存映射：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。

（7）信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。

（8）套接字（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

## (4) 消息队列

1. 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
1. 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
1. 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

## (5) 共享内存

1. 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
1. 因为多个进程可以同时操作，所以需要进行同步。
1. 无名信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

## (6) 信号量

1. 信号量用于进程间同步，若要在进程间传递数据需要结合 _共享内存_ 。
1. 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。

## (7) POSIX信号量和System V信号量的区别

1. 前者兼容性强，后者来源于AT&T System V，是Unix操作系统众多版本中的一支
1. 前者使用头文件<semaphore>,后者使用头文件<sys/sem.h>
1. System V操作的PV操作不一定是-1或者+1 ，可以同时请求和释放多个资源

      sembuf结构体：
      struct sembuf {
       shortsem_num;
       shortsem_op;
       shortsem_flg;
      };
       [//sem_op是信号量一次PV操作时加减的数值](//sem_op是信号量一次PV操作时加减的数值) 

1. System V信号量支持信号量组 

int semget(key_t key, int num_sems, int sem_flags);

 `num_sems 表示初始化信号量的个数` 

 `AND信号量机制,联系哲学家进餐问题` 

## (8) 信号和信号量的区别

1. 前者是使用信号处理器来进行的，后者是使用P,V操作来实现的。
1. 使用信号要先知道有哪些信号，在Linux下有31个需要记住的通用信号
1. 在使用信号以前，首先要初始化信号集，只有在信号集里面的信号才会被考虑。
1. 信号是实现约定的固定的值，而信号量是一 **个** 变量记录着某些特定信息。
1. 信号通知进程发生了异步事件（内存越界,kill），信号量实现进程之间的同步和互斥
1. 信号类似于中断，什么时候产生信号，进程是不知道的。